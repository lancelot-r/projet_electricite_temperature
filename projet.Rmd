---
title: "Untitled"
output: 
  pdf_document: 
    number_sections: true
  html_document: default
date: "2025-02-05"
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
```

# Introduction

La consommation énergétique et les variations de température sont deux phénomènes interdépendants qui jouent un rôle crucial dans la gestion des ressources et la planification des infrastructures. La température influence directement la demande énergétique, notamment à travers les besoins en climatisation lors des épisodes de chaleur. Comprendre cette relation et modéliser ces dynamiques est essentiel pour anticiper les pics de consommation, optimiser la production d'énergie et réduire les coûts associés.

Dans ce travail, nous nous intéressons à l'analyse de la consommation énergétique en fonction des variations de température dans la période d'été (Juillet-Aout). Nous explorerons notamment comment les modèles de lissage exponentiel (comme Holt-Winters) et les modèles SARIMA peuvent être utilisés pour prédire la demande énergétique et les fluctuations climatiques. Enfin, nous explorerons plusieurs moyens de calcul de corrélation entre demande energétique et variations de température.

# Données

Les données analysées dans le cadre de ce projet ont été relevés en 2017 dans la ville de Tetouan, au nord du Maroc (10375 km², estimation à 583374 habitants en 2017). Localisée le long de la mer mediterranée, la température est forte et l'atmosphère est sec durant la période d'été.

Ces données contiennent $n = 52416$ relevés qui, toutes les 10 minutes, fournissent les informations (variables) suivantes : 

```{r include=FALSE}
library(dplyr)
library(lubridate)
library(readr)
library(hms)
library(zoo)
library(forecast)
library(tseries)
library(modelsummary)
library(float)

data <- read.csv("~/github/projet_electricite_temperature/data/powerconsumption.csv", header=T)

data$conso = 
  data$PowerConsumption_Zone1+
  data$PowerConsumption_Zone2+
  data$PowerConsumption_Zone3

data = data %>%
  select(-PowerConsumption_Zone1, -PowerConsumption_Zone2, -PowerConsumption_Zone3, -Humidity, -WindSpeed, -GeneralDiffuseFlows, -DiffuseFlows)

data$Datetime <- as.POSIXct(data$Datetime, format="%m/%d/%Y %H:%M")

data_ete <- data %>%
  filter(month(Datetime) == 7 | month(Datetime) == 8) %>%
  filter(minute((Datetime)) == 0) %>%
  filter(day(Datetime) <= 31)
```

```{r, echo = F}
print("Variables : 'Datetime' (date), 'Temperature' (°c), 'conso' (KW/h)")
```

Afin de faciliter l'analyse, les données de consommation d'énergie provenant des 3 fournisseurs existants (Zone1, Zone2, Zone3) ont été rassemblées une seule mesure ($conso$) décrivant la consommation totale, en KWh, pour la ville de Tetouan. Aussi, nous allons rassembler les données par heures, afin d'avoir $24$ mesures pour une journée, puis trier les données pour ne garder que la période d'été (Debut : 01/07, fin : 31/08) donnant $T = 63$ $[1:63]$ jours et $t=1488$ mesures au total.

```{r, echo = F}
datasummary_skim(data_ete)
```

Sur les données de *data_ete* (Juillet / Aout) :

Pour la $Temperature$, celle-ci varie de 19°c à 40°c, avec une moyenne journalière à 26,5°c

Pour la $conso$, celle-ci varie de $42642.2$ KW/h à $133194.1$ KW/h, avec une moyenne journalière de $87964.8$ KW/h

Aucune valeur manquante ni valeur abérante n'est à déplorer dans nos données.

L'analyse sera séparée en 3 temps : l'analyse de la variable $Temperature$, l'analyse de la variable $conso$ et l'analyse de la corrélation entre les deux mesures.

# Analyse des séries temporelles

## Temperature

```{r}
ts_temp = ts(data_ete$Temperature, frequency = 24, start = c(1,1))
decompose_temp = decompose(ts_temp)
plot(decompose_temp)
```

A partir de la décomposition de la série temporelle *st_temperature* :

- La tendance semble linéaire : malgré les fluctuations visibles, la période estivale analysée donne l'intuition de températures relativement constantes dans les deux mois selectionnés
- Une saissonalité journalière semble se déssiner : l'intuition derrière cette analyse est que malgré une trend constante, les températures baissent la nuit avant de remonter en journée (pic haut à 14, pic bas à 6h **A VERIFIER**)
- La partie résiduelle **A COMPLETER**

Selon ces premières intuitions, nous avons fait le choix de ne pas tenter de modéliser la trend de manière linéaire car les tentatives de modélisations quadratiques et supérieures n'etait pas significativement différent de la modélisation linéaire simple, rajoutant cependant une quantité non négligeable de paramètres au modèle final. Ce choix va cependant influencer le **test kpss de non-stationnarité**  car ce dernier, à la différence du **test de racine unitaire augmenté de Dickey-Fuller**, va détecter la trend non modélisée avec comme conséquence une non-stationnarité de notre série. **ATTENTION ON DOIT CHOISIR SI OUI OU NON ON MODELISE LA TREND ET EXPLIQUER EXPLICITEMENT LE CHOIX**

Maintenant, analysons l'ACF et le Partial ACF de notre série temporelle afin de pouvoir selectionner et paramétrer au mieux notre modèle final :

```{r}
par(mfrow=c(1,2))
acf(ts_temp, main="ts_temp - est.trend", lag.max = 192)
pacf(ts_temp)
```


- Pour l'ACF, la sinuoisalité montre une saissonalité claire, toutes les 24h (ce qui vient confirmer notre intuition de départ). La décroissance lente nous pousse à inclure un terme de moyenne mobile saisonnier de 1. 
- Pour le partial ACF, 


Le **test de racine unitaire augmenté de Dickey Fuller** sur la partie résiduelle de nos données étant **significatif**, nous avons fait le choix de constituer **ATTENTION ON IGNORE LA TREND OU NON ?*

Nous avons donc fait le choix de constituer un modèle $\text{ARIMA(p = 1, d = 0, q = 2)(P = 1, D = 1, Q = 1)[24]}$ : ce modèle contient un terme auto-régressif d'ordre $p = 1$, aucun terme de différenciation car la série est supposée stationnaire **ATTENTION MODELISATION OU NON TREND**, un terme de moyenne mobile d'ordre $q = 1$. Pour la partie saisonnière, celle-ci a été modélisée 

```{r}
manual_arima_temp = arima(ts_temp, order = c(1, 0, 2), seasonal = list(order = c(1, 1, 1), period = 24)) # = auto.arima()
```

```{r}
pB <- Box.test(manual_arima_temp$residuals,type="Ljung")$p.value
par(mfrow=c(1,2))
acf(manual_arima_temp$residuals, main="arima manuel - ACF", ylim = c(-1, 1));pacf(manual_arima_temp$residuals, ylim = c(-1, 1), main = "arima manuel - PACF")
text(0.7,0.7,paste("pval BL=",round(pB,3)))
```

**PEUT ETRE RAJOUER DES COMPARAISONS AVEC D'AUTRES MODELES ?? AIC ??**

Le test de **Ljung-Box** indique que les résidus de notre modèle ARIMA est un bruit blanc (au seuil $\alpha = 99\%$). De plus; l'interprétation graphique de l'ACF et du PACF nous indique que notre modèle capture la quasi-totalité des variations non-aléatoires de notre série temporelle. 

Après analyse, les perturbations de notre modèle semblent homoscédastiques : l'intuition sur la non-variabilité des température moyennes durant ces deux mois viennent confirmer l'analyse, même si les résidus ne sont pas parfaitement heteroscédastiques (**test de Breuch-Pagan d'heteroscédasticité significatif**) **EXPLIQUER L'INTUITION AVEC LA TEMPERATURE**
Les résidus de notre modèle ne suivent pas une loi normale : malgré **l'absence de skew (distribution centrée)**, la distribution de nos rédidus reste **fortement leptokurtique**. 

En réalité, nous n'effectuons pas de test paramétriques sur nos modèles. De plus, notre objectfi étant la modélisation à très court-terme, nous vons choisi de négliger les hypothèses d'homoscédasticité (parfaite) et de normalité des résidus. **ATTENTION BIEN EXPLIQUER POURQUOI ET PARLER DES INTERVALLES DE CONFIANCE**

Afin de s'assurer de la pertinence de notre modèle, nous allons le comparer aux modèles conçus par les algorithmes *auto.arima* (configuré en fonction du BIC **EXPLIQUER POURQUOI**) et modèles de lissage exponentiel automatique de Holt-Winters *ets* **EXPLIQUER UN PEU POURQUOI C'EST BIEN POUR NOTRE MODELE ET QU'EST CE QUE çA PEUT AIDER A CAPTURER EN +**. Ces modèles seront utilisés pour prédire, à 3 jours, la température à chaque heure. Le garphique en rouge, utilisé comme référence, représente les valeurs réelles de température issue de nos données pour le septembre-01.

```{r}
auto_arima_temp <- auto.arima(ts_temp, ic = "bic")
ets_temp <- ets(ts_temp)
```

```{r}
pred_arima <- forecast(manual_arima_temp, h = 192)
pred_auto_arima <- forecast(auto_arima_temp, h = 192)
pred_ets_temp <- forecast(ets_temp, h = 192)

par(mfrow = c(1, 4))
xlim_start <- as.POSIXct("2017-09-01 00:00:00")
xlim_end <- as.POSIXct("2017-09-03 23:00:00")

plot(data$Datetime, data$Temperature, col = "red", type = "l", 
     xlim = c(xlim_start, xlim_end),
     xlab = "Date", ylab = "Temperature (°c)", 
     main = "Données réeles", ylim = c(10, 40))

plot(pred_arima, xlim = c(63, 66), ylim = c(10, 40), main = "manual-ARIMA\n(1,0,2)(0,0,2)[24]",
     xlab = "Date", ylab = "Temperature (°c)",)
plot(pred_auto_arima, xlim = c(63, 66), ylim = c(10, 40), main = "auto-ARIMA\n(2,0,0)(2,1,0)[24]",
     xlab = "Date", ylab = "Temperature (°c)",)
plot(pred_ets_temp, xlim = c(63, 66), ylim = c(10, 40), main = "ets\n(M,Ad,A)",
     xlab = "Date", ylab = "Temperature (°c)")
```

```{r}
# Calculer les métriques pour chaque modèle
accuracy_manual_arima <- round(accuracy(manual_arima_temp), 3)
accuracy_auto_arima <- round(accuracy(auto_arima_temp), 3)
accuracy_ets <- round(accuracy(ets_temp), 3)

# Extraire les AIC et BIC de chaque modèle
aic_manual_arima <- round(manual_arima_temp$aic, 3)

aic_auto_arima <- round(auto_arima_temp$aic, 3)

aic_ets <- round(ets_temp$aic, 3)

# Créer un tableau de comparaison avec AIC et BIC
comparison_table <- rbind(
  c("Manual ARIMA", aic_manual_arima, accuracy_manual_arima),
  c("Auto ARIMA", aic_auto_arima, accuracy_auto_arima),
  c("ETS", aic_ets, accuracy_ets)
)

# Convertir en dataframe pour un affichage propre
comparison_df <- as.data.frame(comparison_table)
colnames(comparison_df) <- c("Modele", "AIC", "ME", "RMSE", "MAE", "MPE", "MAPE", "MASE", "ACF1")

# Afficher le tableau avec kable
library(knitr)
kable(comparison_df, digits = 4, caption = "Performances de prédiction des modèles")
```

